// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.6.1
// - protoc             v6.33.4
// source: api/v1/heimdall.proto

package v1

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	VaultService_Status_FullMethodName = "/heimdall.v1.VaultService/Status"
	VaultService_Lock_FullMethodName   = "/heimdall.v1.VaultService/Lock"
	VaultService_Unlock_FullMethodName = "/heimdall.v1.VaultService/Unlock"
)

// VaultServiceClient is the client API for VaultService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type VaultServiceClient interface {
	Status(ctx context.Context, in *StatusRequest, opts ...grpc.CallOption) (*StatusResponse, error)
	Lock(ctx context.Context, in *LockRequest, opts ...grpc.CallOption) (*LockResponse, error)
	Unlock(ctx context.Context, in *UnlockRequest, opts ...grpc.CallOption) (*UnlockResponse, error)
}

type vaultServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewVaultServiceClient(cc grpc.ClientConnInterface) VaultServiceClient {
	return &vaultServiceClient{cc}
}

func (c *vaultServiceClient) Status(ctx context.Context, in *StatusRequest, opts ...grpc.CallOption) (*StatusResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(StatusResponse)
	err := c.cc.Invoke(ctx, VaultService_Status_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vaultServiceClient) Lock(ctx context.Context, in *LockRequest, opts ...grpc.CallOption) (*LockResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(LockResponse)
	err := c.cc.Invoke(ctx, VaultService_Lock_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vaultServiceClient) Unlock(ctx context.Context, in *UnlockRequest, opts ...grpc.CallOption) (*UnlockResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UnlockResponse)
	err := c.cc.Invoke(ctx, VaultService_Unlock_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// VaultServiceServer is the server API for VaultService service.
// All implementations must embed UnimplementedVaultServiceServer
// for forward compatibility.
type VaultServiceServer interface {
	Status(context.Context, *StatusRequest) (*StatusResponse, error)
	Lock(context.Context, *LockRequest) (*LockResponse, error)
	Unlock(context.Context, *UnlockRequest) (*UnlockResponse, error)
	mustEmbedUnimplementedVaultServiceServer()
}

// UnimplementedVaultServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedVaultServiceServer struct{}

func (UnimplementedVaultServiceServer) Status(context.Context, *StatusRequest) (*StatusResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Status not implemented")
}
func (UnimplementedVaultServiceServer) Lock(context.Context, *LockRequest) (*LockResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Lock not implemented")
}
func (UnimplementedVaultServiceServer) Unlock(context.Context, *UnlockRequest) (*UnlockResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Unlock not implemented")
}
func (UnimplementedVaultServiceServer) mustEmbedUnimplementedVaultServiceServer() {}
func (UnimplementedVaultServiceServer) testEmbeddedByValue()                      {}

// UnsafeVaultServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to VaultServiceServer will
// result in compilation errors.
type UnsafeVaultServiceServer interface {
	mustEmbedUnimplementedVaultServiceServer()
}

func RegisterVaultServiceServer(s grpc.ServiceRegistrar, srv VaultServiceServer) {
	// If the following call panics, it indicates UnimplementedVaultServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&VaultService_ServiceDesc, srv)
}

func _VaultService_Status_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VaultServiceServer).Status(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VaultService_Status_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VaultServiceServer).Status(ctx, req.(*StatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VaultService_Lock_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LockRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VaultServiceServer).Lock(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VaultService_Lock_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VaultServiceServer).Lock(ctx, req.(*LockRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VaultService_Unlock_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UnlockRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VaultServiceServer).Unlock(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VaultService_Unlock_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VaultServiceServer).Unlock(ctx, req.(*UnlockRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// VaultService_ServiceDesc is the grpc.ServiceDesc for VaultService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var VaultService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "heimdall.v1.VaultService",
	HandlerType: (*VaultServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Status",
			Handler:    _VaultService_Status_Handler,
		},
		{
			MethodName: "Lock",
			Handler:    _VaultService_Lock_Handler,
		},
		{
			MethodName: "Unlock",
			Handler:    _VaultService_Unlock_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api/v1/heimdall.proto",
}

const (
	VersionService_GetVersion_FullMethodName = "/heimdall.v1.VersionService/GetVersion"
)

// VersionServiceClient is the client API for VersionService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type VersionServiceClient interface {
	GetVersion(ctx context.Context, in *GetVersionRequest, opts ...grpc.CallOption) (*GetVersionResponse, error)
}

type versionServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewVersionServiceClient(cc grpc.ClientConnInterface) VersionServiceClient {
	return &versionServiceClient{cc}
}

func (c *versionServiceClient) GetVersion(ctx context.Context, in *GetVersionRequest, opts ...grpc.CallOption) (*GetVersionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetVersionResponse)
	err := c.cc.Invoke(ctx, VersionService_GetVersion_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// VersionServiceServer is the server API for VersionService service.
// All implementations must embed UnimplementedVersionServiceServer
// for forward compatibility.
type VersionServiceServer interface {
	GetVersion(context.Context, *GetVersionRequest) (*GetVersionResponse, error)
	mustEmbedUnimplementedVersionServiceServer()
}

// UnimplementedVersionServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedVersionServiceServer struct{}

func (UnimplementedVersionServiceServer) GetVersion(context.Context, *GetVersionRequest) (*GetVersionResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetVersion not implemented")
}
func (UnimplementedVersionServiceServer) mustEmbedUnimplementedVersionServiceServer() {}
func (UnimplementedVersionServiceServer) testEmbeddedByValue()                        {}

// UnsafeVersionServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to VersionServiceServer will
// result in compilation errors.
type UnsafeVersionServiceServer interface {
	mustEmbedUnimplementedVersionServiceServer()
}

func RegisterVersionServiceServer(s grpc.ServiceRegistrar, srv VersionServiceServer) {
	// If the following call panics, it indicates UnimplementedVersionServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&VersionService_ServiceDesc, srv)
}

func _VersionService_GetVersion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetVersionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VersionServiceServer).GetVersion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VersionService_GetVersion_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VersionServiceServer).GetVersion(ctx, req.(*GetVersionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// VersionService_ServiceDesc is the grpc.ServiceDesc for VersionService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var VersionService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "heimdall.v1.VersionService",
	HandlerType: (*VersionServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetVersion",
			Handler:    _VersionService_GetVersion_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api/v1/heimdall.proto",
}

const (
	HostService_CreateHost_FullMethodName = "/heimdall.v1.HostService/CreateHost"
	HostService_GetHost_FullMethodName    = "/heimdall.v1.HostService/GetHost"
	HostService_UpdateHost_FullMethodName = "/heimdall.v1.HostService/UpdateHost"
	HostService_DeleteHost_FullMethodName = "/heimdall.v1.HostService/DeleteHost"
	HostService_ListHosts_FullMethodName  = "/heimdall.v1.HostService/ListHosts"
)

// HostServiceClient is the client API for HostService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type HostServiceClient interface {
	CreateHost(ctx context.Context, in *CreateHostRequest, opts ...grpc.CallOption) (*CreateHostResponse, error)
	GetHost(ctx context.Context, in *GetHostRequest, opts ...grpc.CallOption) (*GetHostResponse, error)
	UpdateHost(ctx context.Context, in *UpdateHostRequest, opts ...grpc.CallOption) (*UpdateHostResponse, error)
	DeleteHost(ctx context.Context, in *DeleteHostRequest, opts ...grpc.CallOption) (*DeleteHostResponse, error)
	ListHosts(ctx context.Context, in *ListHostsRequest, opts ...grpc.CallOption) (*ListHostsResponse, error)
}

type hostServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewHostServiceClient(cc grpc.ClientConnInterface) HostServiceClient {
	return &hostServiceClient{cc}
}

func (c *hostServiceClient) CreateHost(ctx context.Context, in *CreateHostRequest, opts ...grpc.CallOption) (*CreateHostResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateHostResponse)
	err := c.cc.Invoke(ctx, HostService_CreateHost_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hostServiceClient) GetHost(ctx context.Context, in *GetHostRequest, opts ...grpc.CallOption) (*GetHostResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetHostResponse)
	err := c.cc.Invoke(ctx, HostService_GetHost_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hostServiceClient) UpdateHost(ctx context.Context, in *UpdateHostRequest, opts ...grpc.CallOption) (*UpdateHostResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateHostResponse)
	err := c.cc.Invoke(ctx, HostService_UpdateHost_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hostServiceClient) DeleteHost(ctx context.Context, in *DeleteHostRequest, opts ...grpc.CallOption) (*DeleteHostResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteHostResponse)
	err := c.cc.Invoke(ctx, HostService_DeleteHost_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hostServiceClient) ListHosts(ctx context.Context, in *ListHostsRequest, opts ...grpc.CallOption) (*ListHostsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListHostsResponse)
	err := c.cc.Invoke(ctx, HostService_ListHosts_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// HostServiceServer is the server API for HostService service.
// All implementations must embed UnimplementedHostServiceServer
// for forward compatibility.
type HostServiceServer interface {
	CreateHost(context.Context, *CreateHostRequest) (*CreateHostResponse, error)
	GetHost(context.Context, *GetHostRequest) (*GetHostResponse, error)
	UpdateHost(context.Context, *UpdateHostRequest) (*UpdateHostResponse, error)
	DeleteHost(context.Context, *DeleteHostRequest) (*DeleteHostResponse, error)
	ListHosts(context.Context, *ListHostsRequest) (*ListHostsResponse, error)
	mustEmbedUnimplementedHostServiceServer()
}

// UnimplementedHostServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedHostServiceServer struct{}

func (UnimplementedHostServiceServer) CreateHost(context.Context, *CreateHostRequest) (*CreateHostResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method CreateHost not implemented")
}
func (UnimplementedHostServiceServer) GetHost(context.Context, *GetHostRequest) (*GetHostResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetHost not implemented")
}
func (UnimplementedHostServiceServer) UpdateHost(context.Context, *UpdateHostRequest) (*UpdateHostResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method UpdateHost not implemented")
}
func (UnimplementedHostServiceServer) DeleteHost(context.Context, *DeleteHostRequest) (*DeleteHostResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method DeleteHost not implemented")
}
func (UnimplementedHostServiceServer) ListHosts(context.Context, *ListHostsRequest) (*ListHostsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListHosts not implemented")
}
func (UnimplementedHostServiceServer) mustEmbedUnimplementedHostServiceServer() {}
func (UnimplementedHostServiceServer) testEmbeddedByValue()                     {}

// UnsafeHostServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to HostServiceServer will
// result in compilation errors.
type UnsafeHostServiceServer interface {
	mustEmbedUnimplementedHostServiceServer()
}

func RegisterHostServiceServer(s grpc.ServiceRegistrar, srv HostServiceServer) {
	// If the following call panics, it indicates UnimplementedHostServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&HostService_ServiceDesc, srv)
}

func _HostService_CreateHost_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateHostRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HostServiceServer).CreateHost(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: HostService_CreateHost_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HostServiceServer).CreateHost(ctx, req.(*CreateHostRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _HostService_GetHost_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetHostRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HostServiceServer).GetHost(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: HostService_GetHost_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HostServiceServer).GetHost(ctx, req.(*GetHostRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _HostService_UpdateHost_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateHostRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HostServiceServer).UpdateHost(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: HostService_UpdateHost_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HostServiceServer).UpdateHost(ctx, req.(*UpdateHostRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _HostService_DeleteHost_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteHostRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HostServiceServer).DeleteHost(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: HostService_DeleteHost_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HostServiceServer).DeleteHost(ctx, req.(*DeleteHostRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _HostService_ListHosts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListHostsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HostServiceServer).ListHosts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: HostService_ListHosts_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HostServiceServer).ListHosts(ctx, req.(*ListHostsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// HostService_ServiceDesc is the grpc.ServiceDesc for HostService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var HostService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "heimdall.v1.HostService",
	HandlerType: (*HostServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateHost",
			Handler:    _HostService_CreateHost_Handler,
		},
		{
			MethodName: "GetHost",
			Handler:    _HostService_GetHost_Handler,
		},
		{
			MethodName: "UpdateHost",
			Handler:    _HostService_UpdateHost_Handler,
		},
		{
			MethodName: "DeleteHost",
			Handler:    _HostService_DeleteHost_Handler,
		},
		{
			MethodName: "ListHosts",
			Handler:    _HostService_ListHosts_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api/v1/heimdall.proto",
}

const (
	SecretService_CreateSecret_FullMethodName       = "/heimdall.v1.SecretService/CreateSecret"
	SecretService_ListSecrets_FullMethodName        = "/heimdall.v1.SecretService/ListSecrets"
	SecretService_GetSecretValue_FullMethodName     = "/heimdall.v1.SecretService/GetSecretValue"
	SecretService_DeleteSecret_FullMethodName       = "/heimdall.v1.SecretService/DeleteSecret"
	SecretService_UploadFileSecret_FullMethodName   = "/heimdall.v1.SecretService/UploadFileSecret"
	SecretService_DownloadFileSecret_FullMethodName = "/heimdall.v1.SecretService/DownloadFileSecret"
)

// SecretServiceClient is the client API for SecretService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type SecretServiceClient interface {
	CreateSecret(ctx context.Context, in *CreateSecretRequest, opts ...grpc.CallOption) (*CreateSecretResponse, error)
	ListSecrets(ctx context.Context, in *ListSecretsRequest, opts ...grpc.CallOption) (*ListSecretsResponse, error)
	GetSecretValue(ctx context.Context, in *GetSecretValueRequest, opts ...grpc.CallOption) (*GetSecretValueResponse, error)
	DeleteSecret(ctx context.Context, in *DeleteSecretRequest, opts ...grpc.CallOption) (*DeleteSecretResponse, error)
	UploadFileSecret(ctx context.Context, opts ...grpc.CallOption) (grpc.ClientStreamingClient[UploadChunk, UploadFileSecretResponse], error)
	DownloadFileSecret(ctx context.Context, in *DownloadRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[DownloadChunk], error)
}

type secretServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewSecretServiceClient(cc grpc.ClientConnInterface) SecretServiceClient {
	return &secretServiceClient{cc}
}

func (c *secretServiceClient) CreateSecret(ctx context.Context, in *CreateSecretRequest, opts ...grpc.CallOption) (*CreateSecretResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateSecretResponse)
	err := c.cc.Invoke(ctx, SecretService_CreateSecret_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *secretServiceClient) ListSecrets(ctx context.Context, in *ListSecretsRequest, opts ...grpc.CallOption) (*ListSecretsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListSecretsResponse)
	err := c.cc.Invoke(ctx, SecretService_ListSecrets_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *secretServiceClient) GetSecretValue(ctx context.Context, in *GetSecretValueRequest, opts ...grpc.CallOption) (*GetSecretValueResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetSecretValueResponse)
	err := c.cc.Invoke(ctx, SecretService_GetSecretValue_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *secretServiceClient) DeleteSecret(ctx context.Context, in *DeleteSecretRequest, opts ...grpc.CallOption) (*DeleteSecretResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteSecretResponse)
	err := c.cc.Invoke(ctx, SecretService_DeleteSecret_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *secretServiceClient) UploadFileSecret(ctx context.Context, opts ...grpc.CallOption) (grpc.ClientStreamingClient[UploadChunk, UploadFileSecretResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &SecretService_ServiceDesc.Streams[0], SecretService_UploadFileSecret_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[UploadChunk, UploadFileSecretResponse]{ClientStream: stream}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type SecretService_UploadFileSecretClient = grpc.ClientStreamingClient[UploadChunk, UploadFileSecretResponse]

func (c *secretServiceClient) DownloadFileSecret(ctx context.Context, in *DownloadRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[DownloadChunk], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &SecretService_ServiceDesc.Streams[1], SecretService_DownloadFileSecret_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[DownloadRequest, DownloadChunk]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type SecretService_DownloadFileSecretClient = grpc.ServerStreamingClient[DownloadChunk]

// SecretServiceServer is the server API for SecretService service.
// All implementations must embed UnimplementedSecretServiceServer
// for forward compatibility.
type SecretServiceServer interface {
	CreateSecret(context.Context, *CreateSecretRequest) (*CreateSecretResponse, error)
	ListSecrets(context.Context, *ListSecretsRequest) (*ListSecretsResponse, error)
	GetSecretValue(context.Context, *GetSecretValueRequest) (*GetSecretValueResponse, error)
	DeleteSecret(context.Context, *DeleteSecretRequest) (*DeleteSecretResponse, error)
	UploadFileSecret(grpc.ClientStreamingServer[UploadChunk, UploadFileSecretResponse]) error
	DownloadFileSecret(*DownloadRequest, grpc.ServerStreamingServer[DownloadChunk]) error
	mustEmbedUnimplementedSecretServiceServer()
}

// UnimplementedSecretServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedSecretServiceServer struct{}

func (UnimplementedSecretServiceServer) CreateSecret(context.Context, *CreateSecretRequest) (*CreateSecretResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method CreateSecret not implemented")
}
func (UnimplementedSecretServiceServer) ListSecrets(context.Context, *ListSecretsRequest) (*ListSecretsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListSecrets not implemented")
}
func (UnimplementedSecretServiceServer) GetSecretValue(context.Context, *GetSecretValueRequest) (*GetSecretValueResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetSecretValue not implemented")
}
func (UnimplementedSecretServiceServer) DeleteSecret(context.Context, *DeleteSecretRequest) (*DeleteSecretResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method DeleteSecret not implemented")
}
func (UnimplementedSecretServiceServer) UploadFileSecret(grpc.ClientStreamingServer[UploadChunk, UploadFileSecretResponse]) error {
	return status.Error(codes.Unimplemented, "method UploadFileSecret not implemented")
}
func (UnimplementedSecretServiceServer) DownloadFileSecret(*DownloadRequest, grpc.ServerStreamingServer[DownloadChunk]) error {
	return status.Error(codes.Unimplemented, "method DownloadFileSecret not implemented")
}
func (UnimplementedSecretServiceServer) mustEmbedUnimplementedSecretServiceServer() {}
func (UnimplementedSecretServiceServer) testEmbeddedByValue()                       {}

// UnsafeSecretServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to SecretServiceServer will
// result in compilation errors.
type UnsafeSecretServiceServer interface {
	mustEmbedUnimplementedSecretServiceServer()
}

func RegisterSecretServiceServer(s grpc.ServiceRegistrar, srv SecretServiceServer) {
	// If the following call panics, it indicates UnimplementedSecretServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&SecretService_ServiceDesc, srv)
}

func _SecretService_CreateSecret_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateSecretRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SecretServiceServer).CreateSecret(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SecretService_CreateSecret_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SecretServiceServer).CreateSecret(ctx, req.(*CreateSecretRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SecretService_ListSecrets_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListSecretsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SecretServiceServer).ListSecrets(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SecretService_ListSecrets_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SecretServiceServer).ListSecrets(ctx, req.(*ListSecretsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SecretService_GetSecretValue_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSecretValueRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SecretServiceServer).GetSecretValue(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SecretService_GetSecretValue_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SecretServiceServer).GetSecretValue(ctx, req.(*GetSecretValueRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SecretService_DeleteSecret_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteSecretRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SecretServiceServer).DeleteSecret(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SecretService_DeleteSecret_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SecretServiceServer).DeleteSecret(ctx, req.(*DeleteSecretRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SecretService_UploadFileSecret_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(SecretServiceServer).UploadFileSecret(&grpc.GenericServerStream[UploadChunk, UploadFileSecretResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type SecretService_UploadFileSecretServer = grpc.ClientStreamingServer[UploadChunk, UploadFileSecretResponse]

func _SecretService_DownloadFileSecret_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(DownloadRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(SecretServiceServer).DownloadFileSecret(m, &grpc.GenericServerStream[DownloadRequest, DownloadChunk]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type SecretService_DownloadFileSecretServer = grpc.ServerStreamingServer[DownloadChunk]

// SecretService_ServiceDesc is the grpc.ServiceDesc for SecretService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var SecretService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "heimdall.v1.SecretService",
	HandlerType: (*SecretServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateSecret",
			Handler:    _SecretService_CreateSecret_Handler,
		},
		{
			MethodName: "ListSecrets",
			Handler:    _SecretService_ListSecrets_Handler,
		},
		{
			MethodName: "GetSecretValue",
			Handler:    _SecretService_GetSecretValue_Handler,
		},
		{
			MethodName: "DeleteSecret",
			Handler:    _SecretService_DeleteSecret_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "UploadFileSecret",
			Handler:       _SecretService_UploadFileSecret_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "DownloadFileSecret",
			Handler:       _SecretService_DownloadFileSecret_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "api/v1/heimdall.proto",
}

const (
	KeyService_GenerateKey_FullMethodName = "/heimdall.v1.KeyService/GenerateKey"
	KeyService_ImportKey_FullMethodName   = "/heimdall.v1.KeyService/ImportKey"
	KeyService_ListKeys_FullMethodName    = "/heimdall.v1.KeyService/ListKeys"
	KeyService_ShowKey_FullMethodName     = "/heimdall.v1.KeyService/ShowKey"
	KeyService_DeleteKey_FullMethodName   = "/heimdall.v1.KeyService/DeleteKey"
	KeyService_RotateKey_FullMethodName   = "/heimdall.v1.KeyService/RotateKey"
	KeyService_ExportKey_FullMethodName   = "/heimdall.v1.KeyService/ExportKey"
	KeyService_AgentAdd_FullMethodName    = "/heimdall.v1.KeyService/AgentAdd"
	KeyService_AgentRemove_FullMethodName = "/heimdall.v1.KeyService/AgentRemove"
)

// KeyServiceClient is the client API for KeyService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type KeyServiceClient interface {
	GenerateKey(ctx context.Context, in *GenerateKeyRequest, opts ...grpc.CallOption) (*GenerateKeyResponse, error)
	ImportKey(ctx context.Context, in *ImportKeyRequest, opts ...grpc.CallOption) (*ImportKeyResponse, error)
	ListKeys(ctx context.Context, in *ListKeysRequest, opts ...grpc.CallOption) (*ListKeysResponse, error)
	ShowKey(ctx context.Context, in *ShowKeyRequest, opts ...grpc.CallOption) (*ShowKeyResponse, error)
	DeleteKey(ctx context.Context, in *DeleteKeyRequest, opts ...grpc.CallOption) (*DeleteKeyResponse, error)
	RotateKey(ctx context.Context, in *RotateKeyRequest, opts ...grpc.CallOption) (*RotateKeyResponse, error)
	ExportKey(ctx context.Context, in *ExportKeyRequest, opts ...grpc.CallOption) (*ExportKeyResponse, error)
	AgentAdd(ctx context.Context, in *AgentAddRequest, opts ...grpc.CallOption) (*AgentAddResponse, error)
	AgentRemove(ctx context.Context, in *AgentRemoveRequest, opts ...grpc.CallOption) (*AgentRemoveResponse, error)
}

type keyServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewKeyServiceClient(cc grpc.ClientConnInterface) KeyServiceClient {
	return &keyServiceClient{cc}
}

func (c *keyServiceClient) GenerateKey(ctx context.Context, in *GenerateKeyRequest, opts ...grpc.CallOption) (*GenerateKeyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GenerateKeyResponse)
	err := c.cc.Invoke(ctx, KeyService_GenerateKey_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keyServiceClient) ImportKey(ctx context.Context, in *ImportKeyRequest, opts ...grpc.CallOption) (*ImportKeyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ImportKeyResponse)
	err := c.cc.Invoke(ctx, KeyService_ImportKey_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keyServiceClient) ListKeys(ctx context.Context, in *ListKeysRequest, opts ...grpc.CallOption) (*ListKeysResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListKeysResponse)
	err := c.cc.Invoke(ctx, KeyService_ListKeys_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keyServiceClient) ShowKey(ctx context.Context, in *ShowKeyRequest, opts ...grpc.CallOption) (*ShowKeyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ShowKeyResponse)
	err := c.cc.Invoke(ctx, KeyService_ShowKey_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keyServiceClient) DeleteKey(ctx context.Context, in *DeleteKeyRequest, opts ...grpc.CallOption) (*DeleteKeyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteKeyResponse)
	err := c.cc.Invoke(ctx, KeyService_DeleteKey_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keyServiceClient) RotateKey(ctx context.Context, in *RotateKeyRequest, opts ...grpc.CallOption) (*RotateKeyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RotateKeyResponse)
	err := c.cc.Invoke(ctx, KeyService_RotateKey_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keyServiceClient) ExportKey(ctx context.Context, in *ExportKeyRequest, opts ...grpc.CallOption) (*ExportKeyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ExportKeyResponse)
	err := c.cc.Invoke(ctx, KeyService_ExportKey_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keyServiceClient) AgentAdd(ctx context.Context, in *AgentAddRequest, opts ...grpc.CallOption) (*AgentAddResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AgentAddResponse)
	err := c.cc.Invoke(ctx, KeyService_AgentAdd_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keyServiceClient) AgentRemove(ctx context.Context, in *AgentRemoveRequest, opts ...grpc.CallOption) (*AgentRemoveResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AgentRemoveResponse)
	err := c.cc.Invoke(ctx, KeyService_AgentRemove_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// KeyServiceServer is the server API for KeyService service.
// All implementations must embed UnimplementedKeyServiceServer
// for forward compatibility.
type KeyServiceServer interface {
	GenerateKey(context.Context, *GenerateKeyRequest) (*GenerateKeyResponse, error)
	ImportKey(context.Context, *ImportKeyRequest) (*ImportKeyResponse, error)
	ListKeys(context.Context, *ListKeysRequest) (*ListKeysResponse, error)
	ShowKey(context.Context, *ShowKeyRequest) (*ShowKeyResponse, error)
	DeleteKey(context.Context, *DeleteKeyRequest) (*DeleteKeyResponse, error)
	RotateKey(context.Context, *RotateKeyRequest) (*RotateKeyResponse, error)
	ExportKey(context.Context, *ExportKeyRequest) (*ExportKeyResponse, error)
	AgentAdd(context.Context, *AgentAddRequest) (*AgentAddResponse, error)
	AgentRemove(context.Context, *AgentRemoveRequest) (*AgentRemoveResponse, error)
	mustEmbedUnimplementedKeyServiceServer()
}

// UnimplementedKeyServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedKeyServiceServer struct{}

func (UnimplementedKeyServiceServer) GenerateKey(context.Context, *GenerateKeyRequest) (*GenerateKeyResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GenerateKey not implemented")
}
func (UnimplementedKeyServiceServer) ImportKey(context.Context, *ImportKeyRequest) (*ImportKeyResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ImportKey not implemented")
}
func (UnimplementedKeyServiceServer) ListKeys(context.Context, *ListKeysRequest) (*ListKeysResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListKeys not implemented")
}
func (UnimplementedKeyServiceServer) ShowKey(context.Context, *ShowKeyRequest) (*ShowKeyResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ShowKey not implemented")
}
func (UnimplementedKeyServiceServer) DeleteKey(context.Context, *DeleteKeyRequest) (*DeleteKeyResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method DeleteKey not implemented")
}
func (UnimplementedKeyServiceServer) RotateKey(context.Context, *RotateKeyRequest) (*RotateKeyResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method RotateKey not implemented")
}
func (UnimplementedKeyServiceServer) ExportKey(context.Context, *ExportKeyRequest) (*ExportKeyResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ExportKey not implemented")
}
func (UnimplementedKeyServiceServer) AgentAdd(context.Context, *AgentAddRequest) (*AgentAddResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method AgentAdd not implemented")
}
func (UnimplementedKeyServiceServer) AgentRemove(context.Context, *AgentRemoveRequest) (*AgentRemoveResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method AgentRemove not implemented")
}
func (UnimplementedKeyServiceServer) mustEmbedUnimplementedKeyServiceServer() {}
func (UnimplementedKeyServiceServer) testEmbeddedByValue()                    {}

// UnsafeKeyServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to KeyServiceServer will
// result in compilation errors.
type UnsafeKeyServiceServer interface {
	mustEmbedUnimplementedKeyServiceServer()
}

func RegisterKeyServiceServer(s grpc.ServiceRegistrar, srv KeyServiceServer) {
	// If the following call panics, it indicates UnimplementedKeyServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&KeyService_ServiceDesc, srv)
}

func _KeyService_GenerateKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GenerateKeyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeyServiceServer).GenerateKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KeyService_GenerateKey_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeyServiceServer).GenerateKey(ctx, req.(*GenerateKeyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KeyService_ImportKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ImportKeyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeyServiceServer).ImportKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KeyService_ImportKey_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeyServiceServer).ImportKey(ctx, req.(*ImportKeyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KeyService_ListKeys_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListKeysRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeyServiceServer).ListKeys(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KeyService_ListKeys_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeyServiceServer).ListKeys(ctx, req.(*ListKeysRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KeyService_ShowKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ShowKeyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeyServiceServer).ShowKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KeyService_ShowKey_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeyServiceServer).ShowKey(ctx, req.(*ShowKeyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KeyService_DeleteKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteKeyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeyServiceServer).DeleteKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KeyService_DeleteKey_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeyServiceServer).DeleteKey(ctx, req.(*DeleteKeyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KeyService_RotateKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RotateKeyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeyServiceServer).RotateKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KeyService_RotateKey_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeyServiceServer).RotateKey(ctx, req.(*RotateKeyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KeyService_ExportKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ExportKeyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeyServiceServer).ExportKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KeyService_ExportKey_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeyServiceServer).ExportKey(ctx, req.(*ExportKeyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KeyService_AgentAdd_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AgentAddRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeyServiceServer).AgentAdd(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KeyService_AgentAdd_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeyServiceServer).AgentAdd(ctx, req.(*AgentAddRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KeyService_AgentRemove_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AgentRemoveRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeyServiceServer).AgentRemove(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KeyService_AgentRemove_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeyServiceServer).AgentRemove(ctx, req.(*AgentRemoveRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// KeyService_ServiceDesc is the grpc.ServiceDesc for KeyService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var KeyService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "heimdall.v1.KeyService",
	HandlerType: (*KeyServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GenerateKey",
			Handler:    _KeyService_GenerateKey_Handler,
		},
		{
			MethodName: "ImportKey",
			Handler:    _KeyService_ImportKey_Handler,
		},
		{
			MethodName: "ListKeys",
			Handler:    _KeyService_ListKeys_Handler,
		},
		{
			MethodName: "ShowKey",
			Handler:    _KeyService_ShowKey_Handler,
		},
		{
			MethodName: "DeleteKey",
			Handler:    _KeyService_DeleteKey_Handler,
		},
		{
			MethodName: "RotateKey",
			Handler:    _KeyService_RotateKey_Handler,
		},
		{
			MethodName: "ExportKey",
			Handler:    _KeyService_ExportKey_Handler,
		},
		{
			MethodName: "AgentAdd",
			Handler:    _KeyService_AgentAdd_Handler,
		},
		{
			MethodName: "AgentRemove",
			Handler:    _KeyService_AgentRemove_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api/v1/heimdall.proto",
}

const (
	PasskeyService_Enroll_FullMethodName        = "/heimdall.v1.PasskeyService/Enroll"
	PasskeyService_ListPasskeys_FullMethodName  = "/heimdall.v1.PasskeyService/ListPasskeys"
	PasskeyService_RemovePasskey_FullMethodName = "/heimdall.v1.PasskeyService/RemovePasskey"
	PasskeyService_TestPasskey_FullMethodName   = "/heimdall.v1.PasskeyService/TestPasskey"
)

// PasskeyServiceClient is the client API for PasskeyService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type PasskeyServiceClient interface {
	Enroll(ctx context.Context, in *EnrollPasskeyRequest, opts ...grpc.CallOption) (*EnrollPasskeyResponse, error)
	ListPasskeys(ctx context.Context, in *ListPasskeysRequest, opts ...grpc.CallOption) (*ListPasskeysResponse, error)
	RemovePasskey(ctx context.Context, in *RemovePasskeyRequest, opts ...grpc.CallOption) (*RemovePasskeyResponse, error)
	TestPasskey(ctx context.Context, in *TestPasskeyRequest, opts ...grpc.CallOption) (*TestPasskeyResponse, error)
}

type passkeyServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewPasskeyServiceClient(cc grpc.ClientConnInterface) PasskeyServiceClient {
	return &passkeyServiceClient{cc}
}

func (c *passkeyServiceClient) Enroll(ctx context.Context, in *EnrollPasskeyRequest, opts ...grpc.CallOption) (*EnrollPasskeyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EnrollPasskeyResponse)
	err := c.cc.Invoke(ctx, PasskeyService_Enroll_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *passkeyServiceClient) ListPasskeys(ctx context.Context, in *ListPasskeysRequest, opts ...grpc.CallOption) (*ListPasskeysResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListPasskeysResponse)
	err := c.cc.Invoke(ctx, PasskeyService_ListPasskeys_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *passkeyServiceClient) RemovePasskey(ctx context.Context, in *RemovePasskeyRequest, opts ...grpc.CallOption) (*RemovePasskeyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RemovePasskeyResponse)
	err := c.cc.Invoke(ctx, PasskeyService_RemovePasskey_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *passkeyServiceClient) TestPasskey(ctx context.Context, in *TestPasskeyRequest, opts ...grpc.CallOption) (*TestPasskeyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TestPasskeyResponse)
	err := c.cc.Invoke(ctx, PasskeyService_TestPasskey_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// PasskeyServiceServer is the server API for PasskeyService service.
// All implementations must embed UnimplementedPasskeyServiceServer
// for forward compatibility.
type PasskeyServiceServer interface {
	Enroll(context.Context, *EnrollPasskeyRequest) (*EnrollPasskeyResponse, error)
	ListPasskeys(context.Context, *ListPasskeysRequest) (*ListPasskeysResponse, error)
	RemovePasskey(context.Context, *RemovePasskeyRequest) (*RemovePasskeyResponse, error)
	TestPasskey(context.Context, *TestPasskeyRequest) (*TestPasskeyResponse, error)
	mustEmbedUnimplementedPasskeyServiceServer()
}

// UnimplementedPasskeyServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedPasskeyServiceServer struct{}

func (UnimplementedPasskeyServiceServer) Enroll(context.Context, *EnrollPasskeyRequest) (*EnrollPasskeyResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Enroll not implemented")
}
func (UnimplementedPasskeyServiceServer) ListPasskeys(context.Context, *ListPasskeysRequest) (*ListPasskeysResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListPasskeys not implemented")
}
func (UnimplementedPasskeyServiceServer) RemovePasskey(context.Context, *RemovePasskeyRequest) (*RemovePasskeyResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method RemovePasskey not implemented")
}
func (UnimplementedPasskeyServiceServer) TestPasskey(context.Context, *TestPasskeyRequest) (*TestPasskeyResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method TestPasskey not implemented")
}
func (UnimplementedPasskeyServiceServer) mustEmbedUnimplementedPasskeyServiceServer() {}
func (UnimplementedPasskeyServiceServer) testEmbeddedByValue()                        {}

// UnsafePasskeyServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to PasskeyServiceServer will
// result in compilation errors.
type UnsafePasskeyServiceServer interface {
	mustEmbedUnimplementedPasskeyServiceServer()
}

func RegisterPasskeyServiceServer(s grpc.ServiceRegistrar, srv PasskeyServiceServer) {
	// If the following call panics, it indicates UnimplementedPasskeyServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&PasskeyService_ServiceDesc, srv)
}

func _PasskeyService_Enroll_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EnrollPasskeyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PasskeyServiceServer).Enroll(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PasskeyService_Enroll_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PasskeyServiceServer).Enroll(ctx, req.(*EnrollPasskeyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PasskeyService_ListPasskeys_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListPasskeysRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PasskeyServiceServer).ListPasskeys(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PasskeyService_ListPasskeys_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PasskeyServiceServer).ListPasskeys(ctx, req.(*ListPasskeysRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PasskeyService_RemovePasskey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemovePasskeyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PasskeyServiceServer).RemovePasskey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PasskeyService_RemovePasskey_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PasskeyServiceServer).RemovePasskey(ctx, req.(*RemovePasskeyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PasskeyService_TestPasskey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TestPasskeyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PasskeyServiceServer).TestPasskey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PasskeyService_TestPasskey_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PasskeyServiceServer).TestPasskey(ctx, req.(*TestPasskeyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// PasskeyService_ServiceDesc is the grpc.ServiceDesc for PasskeyService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var PasskeyService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "heimdall.v1.PasskeyService",
	HandlerType: (*PasskeyServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Enroll",
			Handler:    _PasskeyService_Enroll_Handler,
		},
		{
			MethodName: "ListPasskeys",
			Handler:    _PasskeyService_ListPasskeys_Handler,
		},
		{
			MethodName: "RemovePasskey",
			Handler:    _PasskeyService_RemovePasskey_Handler,
		},
		{
			MethodName: "TestPasskey",
			Handler:    _PasskeyService_TestPasskey_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api/v1/heimdall.proto",
}

const (
	ConnectService_Plan_FullMethodName = "/heimdall.v1.ConnectService/Plan"
)

// ConnectServiceClient is the client API for ConnectService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ConnectServiceClient interface {
	Plan(ctx context.Context, in *PlanConnectRequest, opts ...grpc.CallOption) (*PlanConnectResponse, error)
}

type connectServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewConnectServiceClient(cc grpc.ClientConnInterface) ConnectServiceClient {
	return &connectServiceClient{cc}
}

func (c *connectServiceClient) Plan(ctx context.Context, in *PlanConnectRequest, opts ...grpc.CallOption) (*PlanConnectResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PlanConnectResponse)
	err := c.cc.Invoke(ctx, ConnectService_Plan_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ConnectServiceServer is the server API for ConnectService service.
// All implementations must embed UnimplementedConnectServiceServer
// for forward compatibility.
type ConnectServiceServer interface {
	Plan(context.Context, *PlanConnectRequest) (*PlanConnectResponse, error)
	mustEmbedUnimplementedConnectServiceServer()
}

// UnimplementedConnectServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedConnectServiceServer struct{}

func (UnimplementedConnectServiceServer) Plan(context.Context, *PlanConnectRequest) (*PlanConnectResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Plan not implemented")
}
func (UnimplementedConnectServiceServer) mustEmbedUnimplementedConnectServiceServer() {}
func (UnimplementedConnectServiceServer) testEmbeddedByValue()                        {}

// UnsafeConnectServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ConnectServiceServer will
// result in compilation errors.
type UnsafeConnectServiceServer interface {
	mustEmbedUnimplementedConnectServiceServer()
}

func RegisterConnectServiceServer(s grpc.ServiceRegistrar, srv ConnectServiceServer) {
	// If the following call panics, it indicates UnimplementedConnectServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&ConnectService_ServiceDesc, srv)
}

func _ConnectService_Plan_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PlanConnectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConnectServiceServer).Plan(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ConnectService_Plan_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConnectServiceServer).Plan(ctx, req.(*PlanConnectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ConnectService_ServiceDesc is the grpc.ServiceDesc for ConnectService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ConnectService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "heimdall.v1.ConnectService",
	HandlerType: (*ConnectServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Plan",
			Handler:    _ConnectService_Plan_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api/v1/heimdall.proto",
}

const (
	AuditService_ListEvents_FullMethodName  = "/heimdall.v1.AuditService/ListEvents"
	AuditService_VerifyChain_FullMethodName = "/heimdall.v1.AuditService/VerifyChain"
)

// AuditServiceClient is the client API for AuditService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type AuditServiceClient interface {
	ListEvents(ctx context.Context, in *ListEventsRequest, opts ...grpc.CallOption) (*ListEventsResponse, error)
	VerifyChain(ctx context.Context, in *VerifyChainRequest, opts ...grpc.CallOption) (*VerifyChainResponse, error)
}

type auditServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewAuditServiceClient(cc grpc.ClientConnInterface) AuditServiceClient {
	return &auditServiceClient{cc}
}

func (c *auditServiceClient) ListEvents(ctx context.Context, in *ListEventsRequest, opts ...grpc.CallOption) (*ListEventsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListEventsResponse)
	err := c.cc.Invoke(ctx, AuditService_ListEvents_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *auditServiceClient) VerifyChain(ctx context.Context, in *VerifyChainRequest, opts ...grpc.CallOption) (*VerifyChainResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(VerifyChainResponse)
	err := c.cc.Invoke(ctx, AuditService_VerifyChain_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AuditServiceServer is the server API for AuditService service.
// All implementations must embed UnimplementedAuditServiceServer
// for forward compatibility.
type AuditServiceServer interface {
	ListEvents(context.Context, *ListEventsRequest) (*ListEventsResponse, error)
	VerifyChain(context.Context, *VerifyChainRequest) (*VerifyChainResponse, error)
	mustEmbedUnimplementedAuditServiceServer()
}

// UnimplementedAuditServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedAuditServiceServer struct{}

func (UnimplementedAuditServiceServer) ListEvents(context.Context, *ListEventsRequest) (*ListEventsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListEvents not implemented")
}
func (UnimplementedAuditServiceServer) VerifyChain(context.Context, *VerifyChainRequest) (*VerifyChainResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method VerifyChain not implemented")
}
func (UnimplementedAuditServiceServer) mustEmbedUnimplementedAuditServiceServer() {}
func (UnimplementedAuditServiceServer) testEmbeddedByValue()                      {}

// UnsafeAuditServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AuditServiceServer will
// result in compilation errors.
type UnsafeAuditServiceServer interface {
	mustEmbedUnimplementedAuditServiceServer()
}

func RegisterAuditServiceServer(s grpc.ServiceRegistrar, srv AuditServiceServer) {
	// If the following call panics, it indicates UnimplementedAuditServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&AuditService_ServiceDesc, srv)
}

func _AuditService_ListEvents_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListEventsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuditServiceServer).ListEvents(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AuditService_ListEvents_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuditServiceServer).ListEvents(ctx, req.(*ListEventsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuditService_VerifyChain_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VerifyChainRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuditServiceServer).VerifyChain(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AuditService_VerifyChain_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuditServiceServer).VerifyChain(ctx, req.(*VerifyChainRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// AuditService_ServiceDesc is the grpc.ServiceDesc for AuditService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var AuditService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "heimdall.v1.AuditService",
	HandlerType: (*AuditServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ListEvents",
			Handler:    _AuditService_ListEvents_Handler,
		},
		{
			MethodName: "VerifyChain",
			Handler:    _AuditService_VerifyChain_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api/v1/heimdall.proto",
}

const (
	BackupService_CreateBackup_FullMethodName  = "/heimdall.v1.BackupService/CreateBackup"
	BackupService_RestoreBackup_FullMethodName = "/heimdall.v1.BackupService/RestoreBackup"
)

// BackupServiceClient is the client API for BackupService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type BackupServiceClient interface {
	CreateBackup(ctx context.Context, in *CreateBackupRequest, opts ...grpc.CallOption) (*CreateBackupResponse, error)
	RestoreBackup(ctx context.Context, in *RestoreBackupRequest, opts ...grpc.CallOption) (*RestoreBackupResponse, error)
}

type backupServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewBackupServiceClient(cc grpc.ClientConnInterface) BackupServiceClient {
	return &backupServiceClient{cc}
}

func (c *backupServiceClient) CreateBackup(ctx context.Context, in *CreateBackupRequest, opts ...grpc.CallOption) (*CreateBackupResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateBackupResponse)
	err := c.cc.Invoke(ctx, BackupService_CreateBackup_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backupServiceClient) RestoreBackup(ctx context.Context, in *RestoreBackupRequest, opts ...grpc.CallOption) (*RestoreBackupResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RestoreBackupResponse)
	err := c.cc.Invoke(ctx, BackupService_RestoreBackup_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// BackupServiceServer is the server API for BackupService service.
// All implementations must embed UnimplementedBackupServiceServer
// for forward compatibility.
type BackupServiceServer interface {
	CreateBackup(context.Context, *CreateBackupRequest) (*CreateBackupResponse, error)
	RestoreBackup(context.Context, *RestoreBackupRequest) (*RestoreBackupResponse, error)
	mustEmbedUnimplementedBackupServiceServer()
}

// UnimplementedBackupServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedBackupServiceServer struct{}

func (UnimplementedBackupServiceServer) CreateBackup(context.Context, *CreateBackupRequest) (*CreateBackupResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method CreateBackup not implemented")
}
func (UnimplementedBackupServiceServer) RestoreBackup(context.Context, *RestoreBackupRequest) (*RestoreBackupResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method RestoreBackup not implemented")
}
func (UnimplementedBackupServiceServer) mustEmbedUnimplementedBackupServiceServer() {}
func (UnimplementedBackupServiceServer) testEmbeddedByValue()                       {}

// UnsafeBackupServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to BackupServiceServer will
// result in compilation errors.
type UnsafeBackupServiceServer interface {
	mustEmbedUnimplementedBackupServiceServer()
}

func RegisterBackupServiceServer(s grpc.ServiceRegistrar, srv BackupServiceServer) {
	// If the following call panics, it indicates UnimplementedBackupServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&BackupService_ServiceDesc, srv)
}

func _BackupService_CreateBackup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateBackupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackupServiceServer).CreateBackup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BackupService_CreateBackup_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackupServiceServer).CreateBackup(ctx, req.(*CreateBackupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackupService_RestoreBackup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RestoreBackupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackupServiceServer).RestoreBackup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BackupService_RestoreBackup_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackupServiceServer).RestoreBackup(ctx, req.(*RestoreBackupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// BackupService_ServiceDesc is the grpc.ServiceDesc for BackupService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var BackupService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "heimdall.v1.BackupService",
	HandlerType: (*BackupServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateBackup",
			Handler:    _BackupService_CreateBackup_Handler,
		},
		{
			MethodName: "RestoreBackup",
			Handler:    _BackupService_RestoreBackup_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api/v1/heimdall.proto",
}

const (
	SessionService_RecordSessionStart_FullMethodName = "/heimdall.v1.SessionService/RecordSessionStart"
	SessionService_RecordSessionEnd_FullMethodName   = "/heimdall.v1.SessionService/RecordSessionEnd"
)

// SessionServiceClient is the client API for SessionService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type SessionServiceClient interface {
	RecordSessionStart(ctx context.Context, in *RecordSessionStartRequest, opts ...grpc.CallOption) (*RecordSessionStartResponse, error)
	RecordSessionEnd(ctx context.Context, in *RecordSessionEndRequest, opts ...grpc.CallOption) (*RecordSessionEndResponse, error)
}

type sessionServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewSessionServiceClient(cc grpc.ClientConnInterface) SessionServiceClient {
	return &sessionServiceClient{cc}
}

func (c *sessionServiceClient) RecordSessionStart(ctx context.Context, in *RecordSessionStartRequest, opts ...grpc.CallOption) (*RecordSessionStartResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RecordSessionStartResponse)
	err := c.cc.Invoke(ctx, SessionService_RecordSessionStart_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sessionServiceClient) RecordSessionEnd(ctx context.Context, in *RecordSessionEndRequest, opts ...grpc.CallOption) (*RecordSessionEndResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RecordSessionEndResponse)
	err := c.cc.Invoke(ctx, SessionService_RecordSessionEnd_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SessionServiceServer is the server API for SessionService service.
// All implementations must embed UnimplementedSessionServiceServer
// for forward compatibility.
type SessionServiceServer interface {
	RecordSessionStart(context.Context, *RecordSessionStartRequest) (*RecordSessionStartResponse, error)
	RecordSessionEnd(context.Context, *RecordSessionEndRequest) (*RecordSessionEndResponse, error)
	mustEmbedUnimplementedSessionServiceServer()
}

// UnimplementedSessionServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedSessionServiceServer struct{}

func (UnimplementedSessionServiceServer) RecordSessionStart(context.Context, *RecordSessionStartRequest) (*RecordSessionStartResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method RecordSessionStart not implemented")
}
func (UnimplementedSessionServiceServer) RecordSessionEnd(context.Context, *RecordSessionEndRequest) (*RecordSessionEndResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method RecordSessionEnd not implemented")
}
func (UnimplementedSessionServiceServer) mustEmbedUnimplementedSessionServiceServer() {}
func (UnimplementedSessionServiceServer) testEmbeddedByValue()                        {}

// UnsafeSessionServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to SessionServiceServer will
// result in compilation errors.
type UnsafeSessionServiceServer interface {
	mustEmbedUnimplementedSessionServiceServer()
}

func RegisterSessionServiceServer(s grpc.ServiceRegistrar, srv SessionServiceServer) {
	// If the following call panics, it indicates UnimplementedSessionServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&SessionService_ServiceDesc, srv)
}

func _SessionService_RecordSessionStart_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RecordSessionStartRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SessionServiceServer).RecordSessionStart(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SessionService_RecordSessionStart_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SessionServiceServer).RecordSessionStart(ctx, req.(*RecordSessionStartRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SessionService_RecordSessionEnd_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RecordSessionEndRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SessionServiceServer).RecordSessionEnd(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SessionService_RecordSessionEnd_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SessionServiceServer).RecordSessionEnd(ctx, req.(*RecordSessionEndRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// SessionService_ServiceDesc is the grpc.ServiceDesc for SessionService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var SessionService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "heimdall.v1.SessionService",
	HandlerType: (*SessionServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RecordSessionStart",
			Handler:    _SessionService_RecordSessionStart_Handler,
		},
		{
			MethodName: "RecordSessionEnd",
			Handler:    _SessionService_RecordSessionEnd_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api/v1/heimdall.proto",
}

const (
	ReauthService_VerifyAssertion_FullMethodName  = "/heimdall.v1.ReauthService/VerifyAssertion"
	ReauthService_VerifyPassphrase_FullMethodName = "/heimdall.v1.ReauthService/VerifyPassphrase"
)

// ReauthServiceClient is the client API for ReauthService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ReauthServiceClient interface {
	VerifyAssertion(ctx context.Context, in *VerifyAssertionRequest, opts ...grpc.CallOption) (*VerifyAssertionResponse, error)
	VerifyPassphrase(ctx context.Context, in *VerifyPassphraseRequest, opts ...grpc.CallOption) (*VerifyPassphraseResponse, error)
}

type reauthServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewReauthServiceClient(cc grpc.ClientConnInterface) ReauthServiceClient {
	return &reauthServiceClient{cc}
}

func (c *reauthServiceClient) VerifyAssertion(ctx context.Context, in *VerifyAssertionRequest, opts ...grpc.CallOption) (*VerifyAssertionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(VerifyAssertionResponse)
	err := c.cc.Invoke(ctx, ReauthService_VerifyAssertion_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reauthServiceClient) VerifyPassphrase(ctx context.Context, in *VerifyPassphraseRequest, opts ...grpc.CallOption) (*VerifyPassphraseResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(VerifyPassphraseResponse)
	err := c.cc.Invoke(ctx, ReauthService_VerifyPassphrase_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ReauthServiceServer is the server API for ReauthService service.
// All implementations must embed UnimplementedReauthServiceServer
// for forward compatibility.
type ReauthServiceServer interface {
	VerifyAssertion(context.Context, *VerifyAssertionRequest) (*VerifyAssertionResponse, error)
	VerifyPassphrase(context.Context, *VerifyPassphraseRequest) (*VerifyPassphraseResponse, error)
	mustEmbedUnimplementedReauthServiceServer()
}

// UnimplementedReauthServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedReauthServiceServer struct{}

func (UnimplementedReauthServiceServer) VerifyAssertion(context.Context, *VerifyAssertionRequest) (*VerifyAssertionResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method VerifyAssertion not implemented")
}
func (UnimplementedReauthServiceServer) VerifyPassphrase(context.Context, *VerifyPassphraseRequest) (*VerifyPassphraseResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method VerifyPassphrase not implemented")
}
func (UnimplementedReauthServiceServer) mustEmbedUnimplementedReauthServiceServer() {}
func (UnimplementedReauthServiceServer) testEmbeddedByValue()                       {}

// UnsafeReauthServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ReauthServiceServer will
// result in compilation errors.
type UnsafeReauthServiceServer interface {
	mustEmbedUnimplementedReauthServiceServer()
}

func RegisterReauthServiceServer(s grpc.ServiceRegistrar, srv ReauthServiceServer) {
	// If the following call panics, it indicates UnimplementedReauthServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&ReauthService_ServiceDesc, srv)
}

func _ReauthService_VerifyAssertion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VerifyAssertionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReauthServiceServer).VerifyAssertion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ReauthService_VerifyAssertion_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReauthServiceServer).VerifyAssertion(ctx, req.(*VerifyAssertionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ReauthService_VerifyPassphrase_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VerifyPassphraseRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReauthServiceServer).VerifyPassphrase(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ReauthService_VerifyPassphrase_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReauthServiceServer).VerifyPassphrase(ctx, req.(*VerifyPassphraseRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ReauthService_ServiceDesc is the grpc.ServiceDesc for ReauthService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ReauthService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "heimdall.v1.ReauthService",
	HandlerType: (*ReauthServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "VerifyAssertion",
			Handler:    _ReauthService_VerifyAssertion_Handler,
		},
		{
			MethodName: "VerifyPassphrase",
			Handler:    _ReauthService_VerifyPassphrase_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api/v1/heimdall.proto",
}
